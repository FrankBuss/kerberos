;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.import		_strcmp
	.import		_strcpy
	.import		_memcpy
	.import		_internalCartType
	.import		_nXbankConfig
	.import		_readCartHeader
	.import		_readNextBankHeader
	.import		_screenPrintSimpleDialog
	.import		_screenAskEraseDialog
	.import		_screenReadInput
	.import		_apStrUnsupportedCRTType
	.import		_apStrUnsupportedCRTData
	.import		_apStrFileOpenError
	.import		_apStrHeaderReadError
	.import		_apStrChipReadError
	.import		_apStrWriteComplete
	.import		_g_strCartName
	.import		_checkFlashType
	.import		_setStatus
	.import		_refreshMainScreen
	.import		_resetCartInfo
	.import		_eraseSector
	.import		_eraseSlot
	.import		_flashWriteBlock
	.import		_flashVerifyBlock
	.import		_flashWriteBankFromFile
	.import		_startUpStart
	.export		_autoWriteCRTImage
	.export		_checkWriteCRTImage
	.export		_checkWriteCRTImageFromUSB
	.export		_checkWriteLOROMImage
	.export		_checkWriteHIROMImage
	.export		_checkWriteKERNALImage
	.export		_checkWriteARImage
	.export		_checkWriteSS5Image
	.export		_eraseAll
	.export		_checkEraseAll
	.export		_checkEraseSlot
	.export		_checkEraseKERNAL
	.export		_checkEraseAR
	.export		_checkEraseSS5
	.import		_g_strFileName
	.import		_fileDlg
	.import		_pSprites
	.import		_selectKERNALSlotDialog
	.import		_selectARSlotDialog
	.import		_checkAskForSlot
	.import		_slotSelect
	.import		_slotSaveName
	.import		_g_nSelectedSlot
	.import		_g_nSlots
	.import		_progressInit
	.import		_timerStart
	.import		_timerStop
	.import		_utilAppendDecimal
	.import		_utilOpenFile
	.import		_utilCloseFile
	.import		_utilRead
	.import		_utilStr
	.import		__BLOCK_BUFFER_START__

.segment	"RODATA"

L0001:
	.byte	$D5,$00,$C3,$48,$45,$43,$4B,$49,$4E,$47,$20,$46,$49,$4C,$45,$00
	.byte	$D2,$45,$41,$44,$49,$4E,$47,$20,$C3,$D2,$D4,$20,$49,$4D,$41,$47
	.byte	$45,$00,$C3,$D2,$D4,$00,$C3,$41,$52,$54,$52,$49,$44,$47,$45,$20
	.byte	$CE,$41,$4D,$45,$00,$D5,$00,$C3,$41,$52,$54,$52,$49,$44,$47,$45
	.byte	$20,$CE,$41,$4D,$45,$00,$C2,$C9,$CE,$00,$C2,$C9,$CE,$00,$C2,$C9
	.byte	$CE,$00,$CB,$C5,$D2,$CE,$C1,$CC,$20,$CE,$41,$4D,$45,$00,$C2,$C9
	.byte	$CE,$00,$C2,$C9,$CE,$00,$D3,$4C,$4F,$54,$20,$00,$CB,$C5,$D2,$CE
	.byte	$C1,$CC,$20,$00

.segment	"BSS"

_m_nBank:
	.res	1,$00
_m_nAddress:
	.res	2,$00
_m_nSize:
	.res	2,$00
_bankHeader:
	.res	16,$00

; ---------------------------------------------------------------
; unsigned char __near__ autoWriteCRTImage (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_autoWriteCRTImage: near

.segment	"BSS"

L014F:
	.res	1,$00

.segment	"CODE"

;
; refreshMainScreen();
;
	jsr     _refreshMainScreen
;
; slotSelect(nSlot);
;
	ldy     #$00
	lda     (sp),y
	jsr     _slotSelect
;
; rv = utilOpenFile(0);
;
	lda     #$00
	jsr     pusha
	jsr     _utilOpenFile
	sta     L014F
;
; if (rv == 1)
;
	cmp     #$01
	bne     L0156
;
; return 0;
;
	ldx     #$00
	txa
	jmp     incsp1
;
; progressInit();
;
L0156:	jsr     _progressInit
;
; rv = writeCrtImage();
;
	jsr     _writeCrtImage
	sta     L014F
;
; utilCloseFile();
;
	jsr     _utilCloseFile
;
; if (rv == CART_RV_OK)
;
	lda     L014F
	cmp     #$01
	bne     L015F
;
; if (g_nSlots > 1 && g_nSelectedSlot != 0)
;
	lda     _g_nSlots
	cmp     #$02
	bcc     L015F
	lda     _g_nSelectedSlot
	beq     L015F
;
; slotSaveName(g_strCartName, ~0);
;
	lda     #<(_g_strCartName)
	ldx     #>(_g_strCartName)
	jsr     pushax
	lda     #$FF
	jsr     _slotSaveName
;
; return 1;
;
L015F:	ldx     #$00
	lda     #$01
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteCRTImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteCRTImage: near

.segment	"BSS"

L0168:
	.res	1,$00

.segment	"CODE"

;
; if (checkAskForSlot() && (writeOpenFile("CRT") == CART_RV_OK))
;
	jsr     _checkAskForSlot
	tax
	beq     L016B
	lda     #<(L0001+34)
	ldx     #>(L0001+34)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	beq     L016A
L016B:	rts
;
; rv = writeCrtImage();
;
L016A:	jsr     _writeCrtImage
	sta     L0168
;
; utilCloseFile();
;
	jsr     _utilCloseFile
;
; timerStop();
;
	jsr     _timerStop
;
; if (rv == CART_RV_OK)
;
	lda     L0168
	cmp     #$01
	bne     L0173
;
; if (g_nSlots > 1 && g_nSelectedSlot != 0)
;
	lda     _g_nSlots
	cmp     #$02
	bcc     L0175
	lda     _g_nSelectedSlot
	beq     L0175
;
; slotSaveName(screenReadInput("Cartridge Name", g_strCartName),
;
	lda     #<(L0001+38)
	ldx     #>(L0001+38)
	jsr     pushax
	lda     #<(_g_strCartName)
	ldx     #>(_g_strCartName)
	jsr     _screenReadInput
	jsr     pushax
;
; ~0);
;
	lda     #$FF
	jsr     _slotSaveName
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
L0175:	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L0173:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteCRTImageFromUSB (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteCRTImageFromUSB: near

.segment	"BSS"

L0181:
	.res	1,$00

.segment	"CODE"

;
; if (checkAskForSlot() && (writeOpenFile("U") == CART_RV_OK))
;
	jsr     _checkAskForSlot
	tax
	beq     L0184
	lda     #<(L0001+53)
	ldx     #>(L0001+53)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	beq     L0183
L0184:	rts
;
; rv = writeCrtImage();
;
L0183:	jsr     _writeCrtImage
	sta     L0181
;
; utilCloseFile();
;
	jsr     _utilCloseFile
;
; timerStop();
;
	jsr     _timerStop
;
; if (rv == CART_RV_OK)
;
	lda     L0181
	cmp     #$01
	bne     L018C
;
; if (g_nSlots > 1 && g_nSelectedSlot != 0)
;
	lda     _g_nSlots
	cmp     #$02
	bcc     L018E
	lda     _g_nSelectedSlot
	beq     L018E
;
; slotSaveName(screenReadInput("Cartridge Name", g_strCartName),
;
	lda     #<(L0001+55)
	ldx     #>(L0001+55)
	jsr     pushax
	lda     #<(_g_strCartName)
	ldx     #>(_g_strCartName)
	jsr     _screenReadInput
	jsr     pushax
;
; ~0);
;
	lda     #$FF
	jsr     _slotSaveName
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
L018E:	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L018C:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteLOROMImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteLOROMImage: near

.segment	"BSS"

L019A:
	.res	1,$00

.segment	"CODE"

;
; if (checkAskForSlot() && (writeOpenFile("BIN") == CART_RV_OK))
;
	jsr     _checkAskForSlot
	tax
	beq     L019D
	lda     #<(L0001+70)
	ldx     #>(L0001+70)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	beq     L019C
L019D:	rts
;
; rv = writeBinImage(0, 0, EP_NON_INTERLEAVED);
;
L019C:	lda     #$00
	jsr     pusha
	jsr     pusha
	jsr     _writeBinImage
	sta     L019A
;
; if (rv == CART_RV_OK)
;
	cmp     #$01
	bne     L01A6
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L01A6:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteHIROMImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteHIROMImage: near

.segment	"BSS"

L01AB:
	.res	1,$00

.segment	"CODE"

;
; if (checkAskForSlot() && (writeOpenFile("BIN") == CART_RV_OK))
;
	jsr     _checkAskForSlot
	tax
	beq     L01AE
	lda     #<(L0001+74)
	ldx     #>(L0001+74)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	beq     L01AD
L01AE:	rts
;
; rv = writeBinImage(0, 1, EP_NON_INTERLEAVED);
;
L01AD:	lda     #$00
	jsr     pusha
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _writeBinImage
	sta     L01AB
;
; if (rv == CART_RV_OK)
;
	cmp     #$01
	bne     L01B7
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L01B7:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteKERNALImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteKERNALImage: near

.segment	"BSS"

L01BC:
	.res	1,$00
L01BD:
	.res	1,$00

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; nKERNAL = selectKERNALSlotDialog();
;
	jsr     _selectKERNALSlotDialog
	sta     L01BC
;
; if (nKERNAL != 0xff)
;
	cmp     #$FF
	beq     L01CC
;
; if (writeOpenFile("BIN") == CART_RV_OK)
;
	lda     #<(L0001+78)
	ldx     #>(L0001+78)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	bne     L01CC
;
; rv = writeBinImage(nKERNAL | FLASH_8K_SECTOR_BIT, 0,
;
	lda     L01BC
	ora     #$80
	jsr     pusha
	lda     #$00
	jsr     pusha
;
; EP_NON_INTERLEAVED);
;
	jsr     _writeBinImage
	sta     L01BD
;
; if (rv == CART_RV_OK)
;
	cmp     #$01
	bne     L01CC
;
; slotSaveName(screenReadInput("KERNAL Name", g_strFileName),
;
	lda     #<(L0001+82)
	ldx     #>(L0001+82)
	jsr     pushax
	lda     #<(_g_strFileName)
	ldx     #>(_g_strFileName)
	jsr     _screenReadInput
	jsr     pushax
;
; nKERNAL);
;
	lda     L01BC
	jsr     _slotSaveName
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L01CC:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteARImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteARImage: near

.segment	"BSS"

L01D6:
	.res	1,$00
L01D7:
	.res	1,$00

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; nAR = selectARSlotDialog();
;
	jsr     _selectARSlotDialog
	sta     L01D6
;
; if (nAR != 0xff)
;
	cmp     #$FF
	beq     L01E6
;
; if (writeOpenFile("BIN") == CART_RV_OK)
;
	lda     #<(L0001+94)
	ldx     #>(L0001+94)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	bne     L01E6
;
; rv = writeBinImage(nAR * 8 + EF3_AR_BANK, 1, EP_NON_INTERLEAVED);
;
	ldx     #$00
	lda     L01D6
	jsr     shlax3
	ldy     #$10
	jsr     incaxy
	jsr     pusha
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _writeBinImage
	sta     L01D7
;
; if (rv == CART_RV_OK)
;
	cmp     #$01
	bne     L01E6
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L01E6:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkWriteSS5Image (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkWriteSS5Image: near

.segment	"BSS"

L01EB:
	.res	1,$00

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; if (writeOpenFile("BIN") == CART_RV_OK)
;
	lda     #<(L0001+98)
	ldx     #>(L0001+98)
	jsr     pushax
	jsr     _writeOpenFile
	cmp     #$01
	bne     L01F6
;
; rv = writeBinImage(EF3_SS5_BANK, 0, EP_INTERLEAVED);
;
	lda     #$20
	jsr     pusha
	lda     #$00
	jsr     pusha
	lda     #$01
	jsr     _writeBinImage
	sta     L01EB
;
; if (rv == CART_RV_OK)
;
	cmp     #$01
	bne     L01F6
;
; screenPrintSimpleDialog(apStrWriteComplete);
;
	lda     #<(_apStrWriteComplete)
	ldx     #>(_apStrWriteComplete)
	jmp     _screenPrintSimpleDialog
;
; }
;
L01F6:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ eraseAll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_eraseAll: near

.segment	"BSS"

L01FB:
	.res	1,$00

.segment	"CODE"

;
; checkFlashType();
;
	jsr     _checkFlashType
;
; for (i = 0; i < g_nSlots; ++i)
;
	lda     #$00
	sta     L01FB
L01FD:	lda     L01FB
	cmp     _g_nSlots
	jcs     _resetCartInfo
;
; slotSelect(i);
;
	lda     L01FB
	jsr     _slotSelect
;
; eraseSlot();
;
	jsr     _eraseSlot
;
; for (i = 0; i < g_nSlots; ++i)
;
	inc     L01FB
	jmp     L01FD

.endproc

; ---------------------------------------------------------------
; void __near__ checkEraseAll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkEraseAll: near

.segment	"CODE"

;
; if (screenAskEraseDialog() == BUTTON_ENTER)
;
	jsr     _screenAskEraseDialog
	cmp     #$01
;
; eraseAll();
;
	jeq     _eraseAll
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkEraseSlot (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkEraseSlot: near

.segment	"CODE"

;
; if (g_nSlots > 1)
;
	lda     _g_nSlots
	cmp     #$02
	bcc     L0210
;
; if (!checkAskForSlot())
;
	jsr     _checkAskForSlot
	tax
;
; return;
;
	beq     L0212
;
; if (screenAskEraseDialog() == BUTTON_ENTER)
;
L0210:	jsr     _screenAskEraseDialog
	cmp     #$01
	bne     L0212
;
; checkFlashType();
;
	jsr     _checkFlashType
;
; eraseSlot();
;
	jsr     _eraseSlot
;
; if (g_nSelectedSlot > 0)
;
	lda     _g_nSelectedSlot
	jeq     _resetCartInfo
;
; strcpy(utilStr, "Slot ");
;
	ldy     #$FF
L021B:	iny
	lda     L0001+102,y
	sta     _utilStr,y
	bne     L021B
;
; utilAppendDecimal(g_nSelectedSlot);
;
	lda     _g_nSelectedSlot
	ldx     #$00
	jsr     _utilAppendDecimal
;
; slotSaveName(utilStr, 0xff);
;
	lda     #<(_utilStr)
	ldx     #>(_utilStr)
	jsr     pushax
	lda     #$FF
	jsr     _slotSaveName
;
; resetCartInfo();
;
	jmp     _resetCartInfo
;
; }
;
L0212:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkEraseKERNAL (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkEraseKERNAL: near

.segment	"BSS"

L0223:
	.res	1,$00

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; nKERNAL = selectKERNALSlotDialog();
;
	jsr     _selectKERNALSlotDialog
	sta     L0223
;
; if (nKERNAL != 0xff)
;
	cmp     #$FF
	beq     L022A
;
; if (screenAskEraseDialog() == BUTTON_ENTER)
;
	jsr     _screenAskEraseDialog
	cmp     #$01
	bne     L022A
;
; checkFlashType();
;
	jsr     _checkFlashType
;
; eraseSector(nKERNAL | FLASH_8K_SECTOR_BIT, 0);
;
	lda     L0223
	ora     #$80
	jsr     pusha
	lda     #$00
	jsr     pusha
	jsr     _eraseSector
;
; strcpy(utilStr, "KERNAL ");
;
	ldy     #$FF
L0233:	iny
	lda     L0001+108,y
	sta     _utilStr,y
	bne     L0233
;
; utilAppendDecimal(nKERNAL + 1);
;
	ldx     #$00
	lda     L0223
	jsr     incax1
	jsr     _utilAppendDecimal
;
; slotSaveName(utilStr, nKERNAL);
;
	lda     #<(_utilStr)
	ldx     #>(_utilStr)
	jsr     pushax
	lda     L0223
	jsr     _slotSaveName
;
; resetCartInfo();
;
	jmp     _resetCartInfo
;
; }
;
L022A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkEraseAR (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkEraseAR: near

.segment	"BSS"

L023B:
	.res	1,$00

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; nAR = selectARSlotDialog();
;
	jsr     _selectARSlotDialog
	sta     L023B
;
; if (nAR != 0xff)
;
	cmp     #$FF
	beq     L0242
;
; if (screenAskEraseDialog() == BUTTON_ENTER)
;
	jsr     _screenAskEraseDialog
	cmp     #$01
	bne     L0242
;
; checkFlashType();
;
	jsr     _checkFlashType
;
; eraseSector(nAR * 8 + EF3_AR_BANK, 1);
;
	ldx     #$00
	lda     L023B
	jsr     shlax3
	ldy     #$10
	jsr     incaxy
	jsr     pusha
	lda     #$01
	jsr     pusha
	jsr     _eraseSector
;
; resetCartInfo();
;
	jmp     _resetCartInfo
;
; }
;
L0242:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ checkEraseSS5 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkEraseSS5: near

.segment	"CODE"

;
; slotSelect(0);
;
	lda     #$00
	jsr     _slotSelect
;
; if (screenAskEraseDialog() == BUTTON_ENTER)
;
	jsr     _screenAskEraseDialog
	cmp     #$01
	bne     L024C
;
; checkFlashType();
;
	jsr     _checkFlashType
;
; eraseSector(EF3_SS5_BANK, 0);
;
	lda     #$20
	jsr     pusha
	lda     #$00
	jsr     pusha
	jsr     _eraseSector
;
; eraseSector(EF3_SS5_BANK, 1);
;
	lda     #$20
	jsr     pusha
	lda     #$01
	jsr     pusha
	jsr     _eraseSector
;
; resetCartInfo();
;
	jmp     _resetCartInfo
;
; }
;
L024C:	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readNextHeader (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readNextHeader: near

.segment	"BSS"

L0020:
	.res	1,$00

.segment	"CODE"

;
; rv = readNextBankHeader(&bankHeader);
;
	lda     #<(_bankHeader)
	ldx     #>(_bankHeader)
	jsr     _readNextBankHeader
	sta     L0020
;
; m_nBank = bankHeader.bank[1] & FLASH_BANK_MASK;
;
	lda     _bankHeader+11
	and     #$3F
	sta     _m_nBank
;
; m_nAddress = 256 * bankHeader.loadAddr[0] + bankHeader.loadAddr[1];
;
	ldx     #$01
	lda     #$00
	jsr     pushax
	lda     _bankHeader+12
	jsr     tosumula0
	clc
	adc     _bankHeader+13
	bcc     L0256
	inx
L0256:	sta     _m_nAddress
	stx     _m_nAddress+1
;
; m_nSize = 256 * bankHeader.romLen[0] + bankHeader.romLen[1];
;
	ldx     #$01
	lda     #$00
	jsr     pushax
	lda     _bankHeader+14
	jsr     tosumula0
	clc
	adc     _bankHeader+15
	bcc     L0257
	inx
L0257:	sta     _m_nSize
	stx     _m_nSize+1
;
; return rv;
;
	ldx     #$00
	lda     L0020
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ writeStartUpCode (__near__ unsigned char*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_writeStartUpCode: near

.segment	"BSS"

L0032:
	.res	5,$00
L0033:
	.res	1,$00

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *pBankOffset = 1;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	ldy     #$00
	sta     (ptr1),y
;
; switch (internalCartType)
;
	lda     _internalCartType
;
; }
;
	cmp     #$02
	beq     L003A
	cmp     #$03
	beq     L003F
	cmp     #$04
	beq     L0044
	cmp     #$05
	beq     L0049
	cmp     #$06
	beq     L0050
	cmp     #$07
	beq     L0055
	jmp     L0058
;
; nConfig = EASYFLASH_IO_8K;
;
L003A:	lda     #$06
	sta     L0033
;
; break;
;
	jmp     L0038
;
; nConfig = EASYFLASH_IO_16K;
;
L003F:	lda     #$07
	sta     L0033
;
; break;
;
	jmp     L0038
;
; nConfig = EASYFLASH_IO_ULTIMAX;
;
L0044:	lda     #$05
	sta     L0033
;
; break;
;
	jmp     L0038
;
; nConfig = EASYFLASH_IO_16K;
;
L0049:	lda     #$07
	sta     L0033
;
; *pBankOffset = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; break;
;
	jmp     L0038
;
; *pBankOffset = 0;
;
L0050:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; return CART_RV_OK; // nothing to do
;
	tax
	lda     #$01
	jmp     incsp2
;
; nConfig = nXbankConfig;
;
L0055:	lda     _nXbankConfig
	sta     L0033
;
; break;
;
	jmp     L0038
;
; screenPrintSimpleDialog(apStrUnsupportedCRTType);
;
L0058:	lda     #<(_apStrUnsupportedCRTType)
	ldx     #>(_apStrUnsupportedCRTType)
	jsr     _screenPrintSimpleDialog
;
; goto err;
;
	jmp     L005B
;
; memcpy(BLOCK_BUFFER, startUpStart, 0x100);
;
L0038:	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	lda     _startUpStart
	ldx     _startUpStart+1
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _memcpy
;
; BLOCK_BUFFER[0] = *pBankOffset;
;
	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	ldy     #$03
	jsr     ldaxysp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jsr     staspidx
;
; BLOCK_BUFFER[1] = nConfig | EASYFLASH_IO_BIT_LED;
;
	lda     #<(__BLOCK_BUFFER_START__)
	sta     ptr1
	lda     #>(__BLOCK_BUFFER_START__)
	sta     ptr1+1
	lda     L0033
	ora     #$80
	ldy     #$01
	sta     (ptr1),y
;
; addr.nSlot = g_nSelectedSlot;
;
	lda     _g_nSelectedSlot
	sta     L0032
;
; addr.nBank = 0;
;
	lda     #$00
	sta     L0032+1
;
; addr.nChip = 1;
;
	sty     L0032+2
;
; addr.nOffset = 0x1e00;
;
	ldx     #$1E
	lda     #$00
	sta     L0032+3
	stx     L0032+3+1
;
; if (!flashWriteBlock(&addr))
;
	lda     #<(L0032)
	ldx     #>(L0032)
	jsr     _flashWriteBlock
	tax
;
; goto err;
;
	jeq     L005B
;
; memcpy(BLOCK_BUFFER, startUpStart + 0x100, 0x100);
;
	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	lda     #$00
	clc
	adc     _startUpStart
	pha
	lda     #$01
	adc     _startUpStart+1
	tax
	pla
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _memcpy
;
; addr.nOffset = 0x1f00;
;
	ldx     #$1F
	lda     #$00
	sta     L0032+3
	stx     L0032+3+1
;
; if (!flashWriteBlock(&addr))
;
	lda     #<(L0032)
	ldx     #>(L0032)
	jsr     _flashWriteBlock
	tax
;
; goto err;
;
	beq     L005B
;
; memcpy(BLOCK_BUFFER, pSprites, 0x100);
;
	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	lda     _pSprites
	ldx     _pSprites+1
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _memcpy
;
; addr.nOffset = 0x1800;
;
	ldx     #$18
	lda     #$00
	sta     L0032+3
	stx     L0032+3+1
;
; if (!flashWriteBlock(&addr))
;
	lda     #<(L0032)
	ldx     #>(L0032)
	jsr     _flashWriteBlock
	tax
;
; goto err;
;
	beq     L005B
;
; memcpy(BLOCK_BUFFER, pSprites + 0x100, 0x100);
;
	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	lda     #$00
	clc
	adc     _pSprites
	pha
	lda     #$01
	adc     _pSprites+1
	tax
	pla
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _memcpy
;
; addr.nOffset = 0x1900;
;
	ldx     #$19
	lda     #$00
	sta     L0032+3
	stx     L0032+3+1
;
; if (!flashWriteBlock(&addr))
;
	lda     #<(L0032)
	ldx     #>(L0032)
	jsr     _flashWriteBlock
	tax
;
; goto err;
;
	beq     L005B
;
; return CART_RV_OK;
;
	ldx     #$00
	lda     #$01
	jmp     incsp2
;
; return CART_RV_ERR;
;
L005B:	ldx     #$00
	txa
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ writeOpenFile (__near__ const unsigned char*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_writeOpenFile: near

.segment	"BSS"

L0095:
	.res	1,$00

.segment	"CODE"

;
; checkFlashType();
;
	jsr     _checkFlashType
;
; if (strcmp(pStrImageType, "U") == 0)
;
	jsr     pushw0sp
	lda     #<(L0001)
	ldx     #>(L0001)
	jsr     _strcmp
	cpx     #$00
	bne     L0097
	cmp     #$00
	bne     L0097
;
; utilOpenFile(UTIL_USE_USB);
;
	lda     #$FE
	jsr     pusha
	jsr     _utilOpenFile
;
; else
;
	jmp     L00A0
;
; rv = fileDlg(pStrImageType);
;
L0097:	jsr     ldax0sp
	jsr     _fileDlg
	sta     L0095
;
; if (!rv)
;
	lda     L0095
	bne     L00A5
;
; return CART_RV_ERR;
;
	tax
	jmp     incsp2
;
; rv = utilOpenFile(0);
;
L00A5:	lda     #$00
	jsr     pusha
	jsr     _utilOpenFile
	sta     L0095
;
; if (rv == 1)
;
	cmp     #$01
	bne     L00AB
;
; screenPrintSimpleDialog(apStrFileOpenError);
;
	lda     #<(_apStrFileOpenError)
	ldx     #>(_apStrFileOpenError)
	jsr     _screenPrintSimpleDialog
;
; while (rv != OPEN_FILE_OK);
;
L00AB:	lda     L0095
	bne     L0097
;
; if (screenAskEraseDialog() != BUTTON_ENTER)
;
L00A0:	jsr     _screenAskEraseDialog
	cmp     #$01
	beq     L00B0
;
; utilCloseFile();
;
	jsr     _utilCloseFile
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
	jmp     incsp2
;
; refreshMainScreen();
;
L00B0:	jsr     _refreshMainScreen
;
; setStatus("Checking file");
;
	lda     #<(L0001+2)
	ldx     #>(L0001+2)
	jsr     _setStatus
;
; progressInit();
;
	jsr     _progressInit
;
; timerStart();
;
	jsr     _timerStart
;
; return CART_RV_OK;
;
	ldx     #$00
	lda     #$01
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ writeCrtImage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_writeCrtImage: near

.segment	"BSS"

L00BB:
	.res	1,$00
L00BC:
	.res	1,$00

.segment	"CODE"

;
; g_strCartName[0] = '\0';
;
	lda     #$00
	sta     _g_strCartName
;
; setStatus("Reading CRT image");
;
	lda     #<(L0001+16)
	ldx     #>(L0001+16)
	jsr     _setStatus
;
; if (!readCartHeader())
;
	ldy     #$00
	jsr     _readCartHeader
	tax
	bne     L00C2
;
; screenPrintSimpleDialog(apStrHeaderReadError);
;
	lda     #<(_apStrHeaderReadError)
	ldx     #>(_apStrHeaderReadError)
	jsr     _screenPrintSimpleDialog
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
	rts
;
; refreshMainScreen();
;
L00C2:	jsr     _refreshMainScreen
;
; if (writeStartUpCode(&nBankOffset) != CART_RV_OK)
;
	lda     #<(L00BC)
	ldx     #>(L00BC)
	jsr     _writeStartUpCode
	cmp     #$01
	beq     L00C8
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
	rts
;
; while ((rv = readNextHeader()) != CART_RV_EOF)
;
L00C8:	jsr     _readNextHeader
	sta     L00BB
	cmp     #$02
	jeq     L00CD
;
; if (rv == CART_RV_OK)
;
	lda     L00BB
	cmp     #$01
	jne     L00D1
;
; m_nBank += nBankOffset;
;
	lda     L00BC
	clc
	adc     _m_nBank
	sta     _m_nBank
;
; if ((m_nAddress == (uint16_t) ROM0_BASE) && (m_nSize <= 0x4000))
;
	lda     _m_nAddress+1
	cmp     #$80
	bne     L00D5
	lda     _m_nAddress
	bne     L00D5
	lda     _m_nSize+1
	cmp     #$40
	bne     L00DC
	lda     _m_nSize
	cmp     #$01
L00DC:	bcs     L00D5
;
; if (m_nSize > 0x2000)
;
	lda     _m_nSize
	cmp     #$01
	lda     _m_nSize+1
	sbc     #$20
	bcc     L00DE
;
; if (!flashWriteBankFromFile(m_nBank, 0, 0x2000) ||
;
	lda     _m_nBank
	jsr     pusha
	lda     #$00
	jsr     pusha
	ldx     #$20
	jsr     pushax
	jsr     _flashWriteBankFromFile
	tax
	beq     L00E1
;
; !flashWriteBankFromFile(m_nBank, 1, m_nSize - 0x2000))
;
	lda     _m_nBank
	jsr     pusha
	lda     #$01
	jsr     pusha
	lda     _m_nSize
	sec
	sbc     #$00
	pha
	lda     _m_nSize+1
	sbc     #$20
	tax
	pla
	jsr     pushax
	jsr     _flashWriteBankFromFile
	tax
	bne     L00C8
;
; return CART_RV_ERR;
;
L00E1:	rts
;
; if (!flashWriteBankFromFile(m_nBank, 0, m_nSize))
;
L00DE:	lda     _m_nBank
	jsr     pusha
	lda     #$00
	jsr     pusha
	lda     _m_nSize
	ldx     _m_nSize+1
	jsr     pushax
	jsr     _flashWriteBankFromFile
	tax
	jne     L00C8
;
; return CART_RV_ERR;
;
	rts
;
; else if (((m_nAddress == (uint16_t) ROM1_BASE) ||
;
L00D5:	lda     _m_nAddress+1
	cmp     #$A0
	bne     L0258
	lda     _m_nAddress
	beq     L00F4
;
; (m_nAddress == (uint16_t) ROM1_BASE_ULTIMAX)) &&
;
L0258:	lda     _m_nAddress+1
	cmp     #$E0
	bne     L00F2
	lda     _m_nAddress
	bne     L00F2
;
; (m_nSize <= 0x2000))
;
L00F4:	lda     _m_nSize+1
	cmp     #$20
	bne     L00FE
	lda     _m_nSize
	cmp     #$01
L00FE:	bcs     L00F2
;
; if (!flashWriteBankFromFile(m_nBank, 1, m_nSize))
;
	lda     _m_nBank
	jsr     pusha
	lda     #$01
	jsr     pusha
	lda     _m_nSize
	ldx     _m_nSize+1
	jsr     pushax
	jsr     _flashWriteBankFromFile
	tax
	jne     L00C8
;
; return CART_RV_ERR;
;
	rts
;
; screenPrintSimpleDialog(apStrUnsupportedCRTData);
;
L00F2:	lda     #<(_apStrUnsupportedCRTData)
	ldx     #>(_apStrUnsupportedCRTData)
	jsr     _screenPrintSimpleDialog
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
	rts
;
; screenPrintSimpleDialog(apStrChipReadError);
;
L00D1:	lda     #<(_apStrChipReadError)
	ldx     #>(_apStrChipReadError)
	jsr     _screenPrintSimpleDialog
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
	rts
;
; return CART_RV_OK;
;
L00CD:	ldx     #$00
	lda     #$01
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ writeBinImage (unsigned char, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_writeBinImage: near

.segment	"BSS"

L0110:
	.res	5,$00
L0111:
	.res	2,$00

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; g_strCartName[0] = '\0';
;
	lda     #$00
	sta     _g_strCartName
;
; refreshMainScreen();
;
	jsr     _refreshMainScreen
;
; addr.nSlot = g_nSelectedSlot;
;
	lda     _g_nSelectedSlot
	sta     L0110
;
; addr.nBank = nStartBank;
;
	ldy     #$02
	lda     (sp),y
	sta     L0110+1
;
; addr.nChip = nChip;
;
	dey
	lda     (sp),y
	sta     L0110+2
;
; addr.nOffset = 0;
;
	lda     #$00
	sta     L0110+3
	sta     L0110+3+1
;
; nBytes = utilRead(BLOCK_BUFFER, 0x100);
;
L011E:	lda     _utilRead
	ldx     _utilRead+1
	jsr     pushax
	lda     #<(__BLOCK_BUFFER_START__)
	ldx     #>(__BLOCK_BUFFER_START__)
	jsr     pushax
	ldx     #$01
	lda     #$00
	pha
	ldy     #$02
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
	sta     L0111
	stx     L0111+1
;
; if (nBytes > 0)
;
	cmp     #$01
	txa
	sbc     #$00
	bvs     L0128
	eor     #$80
L0128:	bpl     L0141
;
; if (!flashWriteBlock(&addr))
;
	lda     #<(L0110)
	ldx     #>(L0110)
	jsr     _flashWriteBlock
	tax
;
; goto retError;
;
	beq     L0145
;
; if (!flashVerifyBlock(&addr))
;
	lda     #<(L0110)
	ldx     #>(L0110)
	jsr     _flashVerifyBlock
	tax
;
; goto retError;
;
	beq     L0145
;
; addr.nOffset += 0x100;
;
	lda     #$00
	clc
	adc     L0110+3
	sta     L0110+3
	lda     #$01
	adc     L0110+3+1
	sta     L0110+3+1
;
; if (addr.nOffset == 0x2000)
;
	cmp     #$20
	bne     L0141
	lda     L0110+3
	bne     L0141
;
; addr.nOffset = 0;
;
	sta     L0110+3
	sta     L0110+3+1
;
; if (interleaved)
;
	tay
	lda     (sp),y
	beq     L0137
;
; if (addr.nChip == 0)
;
	lda     L0110+2
	bne     L0139
;
; addr.nChip = 1;
;
	lda     #$01
	sta     L0110+2
;
; else
;
	jmp     L0141
;
; addr.nChip = 0;
;
L0139:	sty     L0110+2
;
; ++addr.nBank;
;
L0137:	inc     L0110+1
;
; while (nBytes == 0x100);
;
L0141:	lda     L0111+1
	cmp     #$01
	bne     L025B
	lda     L0111
	jeq     L011E
;
; if (addr.nOffset || addr.nBank)
;
L025B:	lda     L0110+3
	ora     L0110+3+1
	bne     L0146
	lda     L0110+1
	beq     L0145
;
; utilCloseFile();
;
L0146:	jsr     _utilCloseFile
;
; timerStop();
;
	jsr     _timerStop
;
; return CART_RV_OK;
;
	ldx     #$00
	lda     #$01
	jmp     incsp3
;
; utilCloseFile();
;
L0145:	jsr     _utilCloseFile
;
; timerStop();
;
	jsr     _timerStop
;
; return CART_RV_ERR;
;
	ldx     #$00
	txa
;
; }
;
	jmp     incsp3

.endproc

